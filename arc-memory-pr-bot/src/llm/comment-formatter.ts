/**
 * Comment Formatter for the Arc Memory PR Bot
 * 
 * This class formats the insights generated by the PR Context Processor
 * as Markdown for GitHub comments.
 */

import { PRInsights, DesignDecisionsInsight, ImpactAnalysis, TestVerification, RiskLevel } from './pr-context-processor.js';

/**
 * Comment Formatter class
 */
export class CommentFormatter {
  /**
   * Format the insights as Markdown for a GitHub comment
   * @param insights The PR insights to format
   * @param prTitle The PR title (optional)
   * @returns The formatted comment as Markdown
   */
  formatComment(insights: PRInsights, prTitle?: string): string {
    // Format the header
    const header = this.formatHeader(prTitle);
    
    // Format the three sections
    const designDecisionsSection = this.formatDesignDecisions(insights.designDecisions);
    const impactAnalysisSection = this.formatImpactAnalysis(insights.impactAnalysis);
    const testVerificationSection = this.formatTestVerification(insights.testVerification);
    
    // Combine all sections
    return [
      header,
      '',
      designDecisionsSection,
      '',
      impactAnalysisSection,
      '',
      testVerificationSection,
    ].join('\n');
  }
  
  /**
   * Format the header section
   * @param prTitle The PR title (optional)
   * @returns The formatted header
   */
  private formatHeader(prTitle?: string): string {
    const titleText = prTitle ? `this "${prTitle}"` : 'this PR';
    
    return `When reviewing ${titleText}, Arc shows you:

1️⃣ The original design decisions behind the code
2️⃣ The predicted impact of the change
3️⃣ Proof that the change was properly tested`;
  }
  
  /**
   * Format the design decisions section
   * @param designDecisions The design decisions insight
   * @returns The formatted design decisions section
   */
  private formatDesignDecisions(designDecisions: DesignDecisionsInsight): string {
    // Format related ADRs if any
    let adrsSection = '';
    if (designDecisions.relatedADRs && designDecisions.relatedADRs.length > 0) {
      adrsSection = `
**Related ADRs:**
${designDecisions.relatedADRs.map(adr => `- **${adr.title}** (${adr.id}): ${adr.relevance}`).join('\n')}`;
    }
    
    // Format related tickets if any
    let ticketsSection = '';
    if (designDecisions.relatedTickets && designDecisions.relatedTickets.length > 0) {
      ticketsSection = `
**Related Tickets:**
${designDecisions.relatedTickets.map(ticket => `- **${ticket.title}** (${ticket.id}): ${ticket.relevance}`).join('\n')}`;
    }
    
    // Format design principles if any
    let principlesSection = '';
    if (designDecisions.designPrinciples && designDecisions.designPrinciples.length > 0) {
      principlesSection = `
**Design Principles:**
${designDecisions.designPrinciples.map(principle => `- ${principle}`).join('\n')}`;
    }
    
    // Format explanation if any
    let explanationSection = '';
    if (designDecisions.explanation) {
      explanationSection = `
**Explanation:**
${designDecisions.explanation}`;
    }
    
    return `### 1️⃣ The original design decisions behind the code

${designDecisions.summary}${adrsSection}${ticketsSection}${principlesSection}${explanationSection}`;
  }
  
  /**
   * Format the impact analysis section
   * @param impactAnalysis The impact analysis insight
   * @returns The formatted impact analysis section
   */
  private formatImpactAnalysis(impactAnalysis: ImpactAnalysis): string {
    // Format risk score with emoji based on level
    const riskEmoji = this.getRiskEmoji(impactAnalysis.riskScore.level);
    const riskScoreSection = `**Risk Score:** ${riskEmoji} ${impactAnalysis.riskScore.score}/100 (${this.capitalizeFirstLetter(impactAnalysis.riskScore.level)})
${impactAnalysis.riskScore.explanation}`;
    
    // Format affected components if any
    let componentsSection = '';
    if (impactAnalysis.affectedComponents && impactAnalysis.affectedComponents.length > 0) {
      componentsSection = `
**Affected Components:**
${impactAnalysis.affectedComponents.map(component => `- **${component.name}**: ${component.impact}`).join('\n')}`;
    }
    
    // Format potential issues if any
    let issuesSection = '';
    if (impactAnalysis.potentialIssues && impactAnalysis.potentialIssues.length > 0) {
      issuesSection = `
**Potential Issues:**
${impactAnalysis.potentialIssues.map(issue => `- ${issue}`).join('\n')}`;
    }
    
    // Format recommendations if any
    let recommendationsSection = '';
    if (impactAnalysis.recommendations && impactAnalysis.recommendations.length > 0) {
      recommendationsSection = `
**Recommendations:**
${impactAnalysis.recommendations.map(recommendation => `- ${recommendation}`).join('\n')}`;
    }
    
    return `### 2️⃣ The predicted impact of the change

${impactAnalysis.summary}

${riskScoreSection}${componentsSection}${issuesSection}${recommendationsSection}`;
  }
  
  /**
   * Format the test verification section
   * @param testVerification The test verification insight
   * @returns The formatted test verification section
   */
  private formatTestVerification(testVerification: TestVerification): string {
    // Format test coverage with emoji based on percentage
    const coverageEmoji = this.getCoverageEmoji(testVerification.testCoverage.percentage);
    const coverageSection = `**Test Coverage:** ${coverageEmoji} ${testVerification.testCoverage.percentage}%
${testVerification.testCoverage.assessment}`;
    
    // Format test gaps if any
    let gapsSection = '';
    if (testVerification.testGaps && testVerification.testGaps.length > 0) {
      gapsSection = `
**Test Gaps:**
${testVerification.testGaps.map(gap => `- ${gap}`).join('\n')}`;
    }
    
    // Format recommendations if any
    let recommendationsSection = '';
    if (testVerification.recommendations && testVerification.recommendations.length > 0) {
      recommendationsSection = `
**Recommendations:**
${testVerification.recommendations.map(recommendation => `- ${recommendation}`).join('\n')}`;
    }
    
    return `### 3️⃣ Proof that the change was properly tested

${testVerification.summary}

${coverageSection}${gapsSection}${recommendationsSection}`;
  }
  
  /**
   * Format a code diff
   * @param diff The diff to format
   * @returns The formatted diff
   */
  formatCodeDiff(diff: string): string {
    return `<details>
<summary>View Code Changes</summary>

\`\`\`diff
${diff}
\`\`\`

</details>`;
  }
  
  /**
   * Get an emoji for a risk level
   * @param level The risk level
   * @returns An emoji representing the risk level
   */
  private getRiskEmoji(level: RiskLevel): string {
    switch (level) {
      case RiskLevel.LOW:
        return '🟢';
      case RiskLevel.MEDIUM:
        return '🟡';
      case RiskLevel.HIGH:
        return '🔴';
      default:
        return '⚪';
    }
  }
  
  /**
   * Get an emoji for a test coverage percentage
   * @param percentage The test coverage percentage
   * @returns An emoji representing the test coverage
   */
  private getCoverageEmoji(percentage: number): string {
    if (percentage >= 80) {
      return '🟢';
    } else if (percentage >= 50) {
      return '🟡';
    } else {
      return '🔴';
    }
  }
  
  /**
   * Capitalize the first letter of a string
   * @param str The string to capitalize
   * @returns The capitalized string
   */
  private capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
