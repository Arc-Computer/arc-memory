/**
 * PR Context Processor for the Arc Memory PR Bot
 * 
 * This class processes PR context information and generates insights using an LLM.
 * It structures the PR context data for the LLM and processes the LLM responses.
 */

import { Logger } from 'probot';
import { BaseLLMClient, LLMRequestOptions, LLMResponse } from './base-llm-client.js';
import { PRContext, FileChange } from '../context-generator.js';
import { LinearTicket, ADR, Commit, PR } from '../graph-service.js';

/**
 * Insight section types
 */
export enum InsightSection {
  DESIGN_DECISIONS = 'design_decisions',
  IMPACT_ANALYSIS = 'impact_analysis',
  TEST_VERIFICATION = 'test_verification',
}

/**
 * Risk level for impact analysis
 */
export enum RiskLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
}

/**
 * Risk score for impact analysis
 */
export interface RiskScore {
  score: number; // 0-100
  level: RiskLevel;
  explanation: string;
}

/**
 * Design decisions insight
 */
export interface DesignDecisionsInsight {
  summary: string;
  relatedADRs: {
    id: string;
    title: string;
    relevance: string;
  }[];
  relatedTickets: {
    id: string;
    title: string;
    relevance: string;
  }[];
  designPrinciples: string[];
  explanation: string;
}

/**
 * Impact analysis insight
 */
export interface ImpactAnalysis {
  summary: string;
  riskScore: RiskScore;
  affectedComponents: {
    name: string;
    impact: string;
  }[];
  potentialIssues: string[];
  recommendations: string[];
}

/**
 * Test verification insight
 */
export interface TestVerification {
  summary: string;
  testCoverage: {
    percentage: number;
    assessment: string;
  };
  testGaps: string[];
  recommendations: string[];
}

/**
 * PR insights generated by the LLM
 */
export interface PRInsights {
  designDecisions: DesignDecisionsInsight;
  impactAnalysis: ImpactAnalysis;
  testVerification: TestVerification;
}

/**
 * PR Context Processor
 */
export class PRContextProcessor {
  private llmClient: BaseLLMClient;
  private logger: Logger;
  
  /**
   * Create a new PR Context Processor
   * @param llmClient The LLM client to use
   * @param logger The logger instance
   */
  constructor(llmClient: BaseLLMClient, logger: Logger) {
    this.llmClient = llmClient;
    this.logger = logger;
  }
  
  /**
   * Generate insights for a PR
   * @param prContext The PR context
   * @returns A promise that resolves to the PR insights
   */
  async generateInsights(prContext: PRContext): Promise<PRInsights> {
    this.logger.info(`Generating insights for PR #${prContext.prNumber}`);
    
    // Generate insights for each section in parallel
    const [designDecisions, impactAnalysis, testVerification] = await Promise.all([
      this.generateDesignDecisionsInsight(prContext),
      this.generateImpactAnalysisInsight(prContext),
      this.generateTestVerificationInsight(prContext),
    ]);
    
    return {
      designDecisions,
      impactAnalysis,
      testVerification,
    };
  }
  
  /**
   * Generate design decisions insight
   * @param prContext The PR context
   * @returns A promise that resolves to the design decisions insight
   */
  private async generateDesignDecisionsInsight(prContext: PRContext): Promise<DesignDecisionsInsight> {
    this.logger.info(`Generating design decisions insight for PR #${prContext.prNumber}`);
    
    // Structure the prompt for design decisions
    const prompt = this.createDesignDecisionsPrompt(prContext);
    
    try {
      // Generate response from LLM
      const response = await this.llmClient.generateResponse(prompt, {
        temperature: 0.3, // Lower temperature for more factual responses
        maxTokens: 1000,
      });
      
      // Parse the response
      return this.parseDesignDecisionsResponse(response.text);
    } catch (error) {
      this.logger.error(`Error generating design decisions insight: ${error}`);
      
      // Return a fallback insight
      return this.createFallbackDesignDecisionsInsight(prContext);
    }
  }
  
  /**
   * Generate impact analysis insight
   * @param prContext The PR context
   * @returns A promise that resolves to the impact analysis insight
   */
  private async generateImpactAnalysisInsight(prContext: PRContext): Promise<ImpactAnalysis> {
    this.logger.info(`Generating impact analysis insight for PR #${prContext.prNumber}`);
    
    // Structure the prompt for impact analysis
    const prompt = this.createImpactAnalysisPrompt(prContext);
    
    try {
      // Generate response from LLM
      const response = await this.llmClient.generateResponse(prompt, {
        temperature: 0.4, // Slightly higher temperature for more creative analysis
        maxTokens: 1000,
      });
      
      // Parse the response
      return this.parseImpactAnalysisResponse(response.text);
    } catch (error) {
      this.logger.error(`Error generating impact analysis insight: ${error}`);
      
      // Return a fallback insight
      return this.createFallbackImpactAnalysisInsight(prContext);
    }
  }
  
  /**
   * Generate test verification insight
   * @param prContext The PR context
   * @returns A promise that resolves to the test verification insight
   */
  private async generateTestVerificationInsight(prContext: PRContext): Promise<TestVerification> {
    this.logger.info(`Generating test verification insight for PR #${prContext.prNumber}`);
    
    // Structure the prompt for test verification
    const prompt = this.createTestVerificationPrompt(prContext);
    
    try {
      // Generate response from LLM
      const response = await this.llmClient.generateResponse(prompt, {
        temperature: 0.3, // Lower temperature for more factual responses
        maxTokens: 1000,
      });
      
      // Parse the response
      return this.parseTestVerificationResponse(response.text);
    } catch (error) {
      this.logger.error(`Error generating test verification insight: ${error}`);
      
      // Return a fallback insight
      return this.createFallbackTestVerificationInsight(prContext);
    }
  }
  
  /**
   * Create a prompt for design decisions
   * @param prContext The PR context
   * @returns The prompt
   */
  private createDesignDecisionsPrompt(prContext: PRContext): string {
    // Extract relevant information from the PR context
    const { prTitle, prBody, changedFiles, relatedEntities } = prContext;
    const { linearTickets, adrs } = relatedEntities;
    
    // Format the changed files
    const formattedFiles = changedFiles.map(file => 
      `${file.filename} (${file.status}, +${file.additions}, -${file.deletions})`
    ).join('\n');
    
    // Format the Linear tickets
    const formattedTickets = linearTickets.map(ticket => 
      `${ticket.id.split('/')[1]}: ${ticket.title} (${ticket.state})`
    ).join('\n');
    
    // Format the ADRs
    const formattedADRs = adrs.map(adr => 
      `${adr.id}: ${adr.title} (${adr.status})`
    ).join('\n');
    
    // Create the prompt
    return `
You are an expert software architect analyzing a pull request to understand the design decisions behind the code changes.

PR Title: ${prTitle}
PR Description: ${prBody}

Changed Files:
${formattedFiles}

${linearTickets.length > 0 ? `Related Linear Tickets:
${formattedTickets}` : 'No related Linear tickets found.'}

${adrs.length > 0 ? `Related Architectural Decision Records (ADRs):
${formattedADRs}` : 'No related ADRs found.'}

Based on the information above, analyze the design decisions behind this PR. Consider:
1. What architectural principles or patterns are being applied?
2. How do these changes relate to the ADRs and Linear tickets?
3. What design trade-offs were made?

Provide your analysis in the following JSON format:
{
  "summary": "A brief summary of the design decisions",
  "relatedADRs": [
    {
      "id": "ADR ID",
      "title": "ADR title",
      "relevance": "How this ADR relates to the changes"
    }
  ],
  "relatedTickets": [
    {
      "id": "Ticket ID",
      "title": "Ticket title",
      "relevance": "How this ticket relates to the changes"
    }
  ],
  "designPrinciples": [
    "List of design principles or patterns applied"
  ],
  "explanation": "A detailed explanation of the design decisions"
}

If there are no related ADRs or tickets, make educated guesses about the design decisions based on the code changes and PR description.
`;
  }
  
  /**
   * Create a prompt for impact analysis
   * @param prContext The PR context
   * @returns The prompt
   */
  private createImpactAnalysisPrompt(prContext: PRContext): string {
    // Extract relevant information from the PR context
    const { prTitle, prBody, changedFiles, relatedEntities } = prContext;
    const { relatedPRs } = relatedEntities;
    
    // Format the changed files
    const formattedFiles = changedFiles.map(file => 
      `${file.filename} (${file.status}, +${file.additions}, -${file.deletions})`
    ).join('\n');
    
    // Format the related PRs
    const formattedRelatedPRs = relatedPRs.map(pr => 
      `#${pr.number}: ${pr.title} (${pr.state})`
    ).join('\n');
    
    // Create the prompt
    return `
You are an expert software engineer analyzing a pull request to assess its potential impact and risks.

PR Title: ${prTitle}
PR Description: ${prBody}

Changed Files:
${formattedFiles}

${relatedPRs.length > 0 ? `Related PRs:
${formattedRelatedPRs}` : 'No related PRs found.'}

Based on the information above, analyze the potential impact of this PR. Consider:
1. What components or systems might be affected?
2. What is the risk level (low, medium, high) and why?
3. Are there any potential issues or edge cases?
4. What recommendations would you make to minimize risk?

Provide your analysis in the following JSON format:
{
  "summary": "A brief summary of the impact analysis",
  "riskScore": {
    "score": 0-100,
    "level": "low|medium|high",
    "explanation": "Explanation of the risk score"
  },
  "affectedComponents": [
    {
      "name": "Component name",
      "impact": "Description of the impact on this component"
    }
  ],
  "potentialIssues": [
    "List of potential issues or edge cases"
  ],
  "recommendations": [
    "List of recommendations to minimize risk"
  ]
}

Base your risk assessment on the scope and nature of the changes, not just the number of files changed.
`;
  }
  
  /**
   * Create a prompt for test verification
   * @param prContext The PR context
   * @returns The prompt
   */
  private createTestVerificationPrompt(prContext: PRContext): string {
    // Extract relevant information from the PR context
    const { prTitle, prBody, changedFiles, relatedEntities } = prContext;
    const { commits } = relatedEntities;
    
    // Format the changed files
    const formattedFiles = changedFiles.map(file => 
      `${file.filename} (${file.status}, +${file.additions}, -${file.deletions})`
    ).join('\n');
    
    // Format the commits
    const formattedCommits = commits.map(commit => 
      `${commit.sha.substring(0, 7)}: ${commit.title}`
    ).join('\n');
    
    // Check if test files were changed
    const testFiles = changedFiles.filter(file => 
      file.filename.includes('test') || 
      file.filename.includes('spec') || 
      file.filename.includes('__tests__')
    );
    
    // Create the prompt
    return `
You are an expert software engineer analyzing a pull request to verify that the changes are properly tested.

PR Title: ${prTitle}
PR Description: ${prBody}

Changed Files:
${formattedFiles}

${commits.length > 0 ? `Commits:
${formattedCommits}` : 'No commits found.'}

${testFiles.length > 0 ? `Test Files Changed:
${testFiles.map(file => file.filename).join('\n')}` : 'No test files were changed in this PR.'}

Based on the information above, analyze the test coverage of this PR. Consider:
1. Are the changes properly tested?
2. What is the estimated test coverage percentage?
3. Are there any gaps in the test coverage?
4. What recommendations would you make to improve test coverage?

Provide your analysis in the following JSON format:
{
  "summary": "A brief summary of the test verification",
  "testCoverage": {
    "percentage": 0-100,
    "assessment": "Assessment of the test coverage"
  },
  "testGaps": [
    "List of gaps in the test coverage"
  ],
  "recommendations": [
    "List of recommendations to improve test coverage"
  ]
}

If no test files were changed, consider this a potential issue and recommend adding tests.
`;
  }
  
  /**
   * Parse the design decisions response
   * @param responseText The response text from the LLM
   * @returns The parsed design decisions insight
   */
  private parseDesignDecisionsResponse(responseText: string): DesignDecisionsInsight {
    try {
      // Try to parse the response as JSON
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsedResponse = JSON.parse(jsonMatch[0]);
        
        // Validate and return the parsed response
        return {
          summary: parsedResponse.summary || 'No summary provided',
          relatedADRs: Array.isArray(parsedResponse.relatedADRs) ? parsedResponse.relatedADRs : [],
          relatedTickets: Array.isArray(parsedResponse.relatedTickets) ? parsedResponse.relatedTickets : [],
          designPrinciples: Array.isArray(parsedResponse.designPrinciples) ? parsedResponse.designPrinciples : [],
          explanation: parsedResponse.explanation || 'No explanation provided',
        };
      }
    } catch (error) {
      this.logger.error(`Error parsing design decisions response: ${error}`);
    }
    
    // If parsing fails, return a default insight
    return {
      summary: 'Unable to parse design decisions insight',
      relatedADRs: [],
      relatedTickets: [],
      designPrinciples: [],
      explanation: 'The LLM response could not be parsed as JSON. Please check the logs for details.',
    };
  }
  
  /**
   * Parse the impact analysis response
   * @param responseText The response text from the LLM
   * @returns The parsed impact analysis insight
   */
  private parseImpactAnalysisResponse(responseText: string): ImpactAnalysis {
    try {
      // Try to parse the response as JSON
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsedResponse = JSON.parse(jsonMatch[0]);
        
        // Validate and return the parsed response
        return {
          summary: parsedResponse.summary || 'No summary provided',
          riskScore: {
            score: parsedResponse.riskScore?.score || 50,
            level: parsedResponse.riskScore?.level || RiskLevel.MEDIUM,
            explanation: parsedResponse.riskScore?.explanation || 'No explanation provided',
          },
          affectedComponents: Array.isArray(parsedResponse.affectedComponents) ? parsedResponse.affectedComponents : [],
          potentialIssues: Array.isArray(parsedResponse.potentialIssues) ? parsedResponse.potentialIssues : [],
          recommendations: Array.isArray(parsedResponse.recommendations) ? parsedResponse.recommendations : [],
        };
      }
    } catch (error) {
      this.logger.error(`Error parsing impact analysis response: ${error}`);
    }
    
    // If parsing fails, return a default insight
    return {
      summary: 'Unable to parse impact analysis insight',
      riskScore: {
        score: 50,
        level: RiskLevel.MEDIUM,
        explanation: 'The LLM response could not be parsed as JSON. Please check the logs for details.',
      },
      affectedComponents: [],
      potentialIssues: [],
      recommendations: [],
    };
  }
  
  /**
   * Parse the test verification response
   * @param responseText The response text from the LLM
   * @returns The parsed test verification insight
   */
  private parseTestVerificationResponse(responseText: string): TestVerification {
    try {
      // Try to parse the response as JSON
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsedResponse = JSON.parse(jsonMatch[0]);
        
        // Validate and return the parsed response
        return {
          summary: parsedResponse.summary || 'No summary provided',
          testCoverage: {
            percentage: parsedResponse.testCoverage?.percentage || 0,
            assessment: parsedResponse.testCoverage?.assessment || 'No assessment provided',
          },
          testGaps: Array.isArray(parsedResponse.testGaps) ? parsedResponse.testGaps : [],
          recommendations: Array.isArray(parsedResponse.recommendations) ? parsedResponse.recommendations : [],
        };
      }
    } catch (error) {
      this.logger.error(`Error parsing test verification response: ${error}`);
    }
    
    // If parsing fails, return a default insight
    return {
      summary: 'Unable to parse test verification insight',
      testCoverage: {
        percentage: 0,
        assessment: 'The LLM response could not be parsed as JSON. Please check the logs for details.',
      },
      testGaps: [],
      recommendations: [],
    };
  }
  
  /**
   * Create a fallback design decisions insight
   * @param prContext The PR context
   * @returns A fallback design decisions insight
   */
  private createFallbackDesignDecisionsInsight(prContext: PRContext): DesignDecisionsInsight {
    const { prTitle, relatedEntities } = prContext;
    const { adrs, linearTickets } = relatedEntities;
    
    return {
      summary: `Design decisions for "${prTitle}"`,
      relatedADRs: adrs.map(adr => ({
        id: adr.id,
        title: adr.title || 'Untitled ADR',
        relevance: 'This ADR may be related to the changes in this PR.',
      })),
      relatedTickets: linearTickets.map(ticket => ({
        id: ticket.id.split('/')[1],
        title: ticket.title || 'Untitled ticket',
        relevance: 'This ticket is related to the changes in this PR.',
      })),
      designPrinciples: ['Unable to determine design principles due to LLM error'],
      explanation: 'Unable to generate design decisions insight due to an error with the LLM. Please check the logs for details.',
    };
  }
  
  /**
   * Create a fallback impact analysis insight
   * @param prContext The PR context
   * @returns A fallback impact analysis insight
   */
  private createFallbackImpactAnalysisInsight(prContext: PRContext): ImpactAnalysis {
    const { prTitle, changedFiles } = prContext;
    
    // Group changed files by directory
    const directories = new Set<string>();
    changedFiles.forEach(file => {
      const directory = file.filename.split('/').slice(0, -1).join('/');
      if (directory) {
        directories.add(directory);
      }
    });
    
    return {
      summary: `Impact analysis for "${prTitle}"`,
      riskScore: {
        score: 50,
        level: RiskLevel.MEDIUM,
        explanation: 'Unable to determine risk score due to LLM error. Assuming medium risk.',
      },
      affectedComponents: Array.from(directories).map(directory => ({
        name: directory,
        impact: 'Files in this directory were modified.',
      })),
      potentialIssues: ['Unable to determine potential issues due to LLM error'],
      recommendations: ['Review the changes manually to assess potential impact'],
    };
  }
  
  /**
   * Create a fallback test verification insight
   * @param prContext The PR context
   * @returns A fallback test verification insight
   */
  private createFallbackTestVerificationInsight(prContext: PRContext): TestVerification {
    const { prTitle, changedFiles } = prContext;
    
    // Check if test files were changed
    const testFiles = changedFiles.filter(file => 
      file.filename.includes('test') || 
      file.filename.includes('spec') || 
      file.filename.includes('__tests__')
    );
    
    return {
      summary: `Test verification for "${prTitle}"`,
      testCoverage: {
        percentage: testFiles.length > 0 ? 50 : 0,
        assessment: testFiles.length > 0 
          ? 'Some test files were changed, but unable to assess coverage due to LLM error.' 
          : 'No test files were changed in this PR.',
      },
      testGaps: ['Unable to determine test gaps due to LLM error'],
      recommendations: [
        'Ensure that all changed code is covered by tests',
        'Add unit tests for new functionality',
        'Add integration tests for complex interactions',
      ],
    };
  }
}
